import { Node, Edge } from 'reactflow'
import { EnhancedCapsule } from './capsules-enhanced'

export interface WorkflowCodeOptions {
  nodes: Node[]
  edges: Edge[]
  nodeConfig: Record<string, any>
}

export function generateProductionCode(options: WorkflowCodeOptions): string {
  const { nodes, edges, nodeConfig } = options

  // Build dependency graph
  const graph = buildDependencyGraph(nodes, edges)

  // Topological sort for execution order
  const executionOrder = topologicalSort(graph)

  let code = `/**
 * Generated Workflow Code
 * Auto-generated by HubLab Workflow Builder
 *
 * This code is production-ready and can be deployed directly.
 */\n\n`

  // Collect npm packages
  const packages = new Set<string>()
  nodes.forEach(node => {
    const capsule = node.data.capsule as EnhancedCapsule
    if (capsule.npmPackage) {
      packages.add(capsule.npmPackage)
    }
  })

  if (packages.size > 0) {
    code += `// Install dependencies:\n`
    code += `// npm install ${Array.from(packages).join(' ')}\n\n`
  }

  // Extract environment variables
  const envVars = extractEnvVars(nodeConfig)
  if (envVars.size > 0) {
    code += `// Required environment variables:\n`
    envVars.forEach(v => {
      code += `// ${v}=your_value_here\n`
    })
    code += `\n`
  }

  // Imports
  code += `import { createWorkflow, WorkflowContext } from 'capsulas-framework'\n\n`

  // Workflow definition
  code += `interface WorkflowInput {\n`
  code += `  // Define your input data structure here\n`
  code += `  [key: string]: any\n`
  code += `}\n\n`

  code += `export async function executeWorkflow(input: WorkflowInput) {\n`
  code += `  const ctx: WorkflowContext = { input, results: {} }\n\n`

  // Generate code for each node in execution order
  executionOrder.forEach((nodeId, index) => {
    const node = nodes.find(n => n.id === nodeId)
    if (!node) return

    const capsule = node.data.capsule as EnhancedCapsule
    const config = nodeConfig[nodeId] || {}

    code += `  // Step ${index + 1}: ${capsule.name}\n`
    code += `  try {\n`

    // Get input from previous node
    const incomingEdges = edges.filter(e => e.target === nodeId)
    if (incomingEdges.length > 0) {
      const sourceNode = nodes.find(n => n.id === incomingEdges[0].source)
      if (sourceNode) {
        code += `    const ${nodeId}_input = ctx.results['${incomingEdges[0].source}']\n`
      }
    }

    // Generate node-specific code
    if (capsule.codeTemplate) {
      let nodeCode = capsule.codeTemplate

      // Replace config placeholders
      Object.keys(config).forEach(key => {
        const value = config[key]
        const placeholder = new RegExp(`{{config\\.${key}}}`, 'g')
        if (typeof value === 'string') {
          nodeCode = nodeCode.replace(placeholder, value)
        } else {
          nodeCode = nodeCode.replace(placeholder, JSON.stringify(value))
        }
      })

      // Replace prevOutput with actual input
      if (incomingEdges.length > 0) {
        nodeCode = nodeCode.replace(/prevOutput/g, `${nodeId}_input`)
      }

      code += `    ${nodeCode.split('\n').join('\n    ')}\n`
    } else {
      code += `    // TODO: Implement ${capsule.name} logic\n`
      code += `    const ${nodeId}_output = { /* ${capsule.name} result */ }\n`
    }

    // Store result
    code += `    ctx.results['${nodeId}'] = ${nodeId}_output || ${nodeId}_input\n`

    code += `  } catch (error) {\n`
    code += `    console.error('Error in ${capsule.name}:', error)\n`
    code += `    throw error\n`
    code += `  }\n\n`
  })

  // Return final result
  if (executionOrder.length > 0) {
    const lastNodeId = executionOrder[executionOrder.length - 1]
    code += `  return ctx.results['${lastNodeId}']\n`
  } else {
    code += `  return ctx.results\n`
  }

  code += `}\n\n`

  // Usage example
  code += `// Usage example:\n`
  code += `// const result = await executeWorkflow({ /* your input */ })\n`
  code += `// console.log('Workflow result:', result)\n`

  return code
}

function buildDependencyGraph(nodes: Node[], edges: Edge[]): Map<string, string[]> {
  const graph = new Map<string, string[]>()

  nodes.forEach(node => {
    graph.set(node.id, [])
  })

  edges.forEach(edge => {
    const dependencies = graph.get(edge.target) || []
    dependencies.push(edge.source)
    graph.set(edge.target, dependencies)
  })

  return graph
}

function topologicalSort(graph: Map<string, string[]>): string[] {
  const sorted: string[] = []
  const visited = new Set<string>()
  const visiting = new Set<string>()

  function visit(nodeId: string) {
    if (visited.has(nodeId)) return
    if (visiting.has(nodeId)) {
      throw new Error('Circular dependency detected')
    }

    visiting.add(nodeId)

    const dependencies = graph.get(nodeId) || []
    dependencies.forEach(depId => visit(depId))

    visiting.delete(nodeId)
    visited.add(nodeId)
    sorted.push(nodeId)
  }

  Array.from(graph.keys()).forEach(nodeId => visit(nodeId))

  return sorted
}

function extractEnvVars(nodeConfig: Record<string, any>): Set<string> {
  const envVars = new Set<string>()

  Object.values(nodeConfig).forEach(config => {
    Object.values(config).forEach(value => {
      if (typeof value === 'string') {
        const matches = value.matchAll(/\$\{([^}]+)\}|process\.env\.([A-Z_]+)/g)
        for (const match of matches) {
          envVars.add(match[1] || match[2])
        }
      }
    })
  })

  return envVars
}
